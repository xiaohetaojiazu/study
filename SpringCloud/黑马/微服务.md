# 导学篇

## 0.1 什么是微服务？

首先要明确微服务绝对不等于 SpringCloud，SpringCloud仅仅解决了服务拆分时的服务治理问题，对于其他分布式的问题并没有给出解决方案。或者说，SpringCloud 仅仅是微服务中的一部分

## 0.2 微服务技术栈

<a href="https://imgse.com/i/piQRXyd"><img src="微服务.pic/piQRXyd.png" alt="piQRXyd.png" border="0" /></a>

- 服务集群：有很多负责单一功能的服务组成的服务集群，共同来完成一个业务。服务之间存在复杂的调用关系。

- 注册中心：管理和记录服务。记录提供的服务和地址（IP + 端口）。服务之间不需要知道对方的地址，只需在配置中心查找要调用的服务的地址，进行调用。

- 配置中心：管理服务集群中的配置。可以通知服务集群中的服务，实现配置的热更新。

- 服务网关

  1. 校验用户身份，拦截非法请求
  2. 将合法请求路由到正确的具体的服务
  3. 负载均衡

- 分布式缓存

  缓存简单查询

- 分布式搜索

  实现复杂查询

- 消息队列

  解耦服务调用，实现异步调用
  
- 分布式日志服务
  负责统计集群中所有服务的日志，统一地存储统计分析 

- 系统的监控和链路追踪
  实时监控集群中每个节点的运行状态信息，一旦出现问题，可以定位到具体的方法 

- 自动化部署技术 

  - Jenkins
  - docker
  - kubernetes
  - rancher

## 0.2 微服务技术栈的大类划分

- 微服务治理
- 缓存技术
- 搜索技术
- 异步通信技术
- DevOps



# 第 1 章 认识微服务

## 1.1 微服务架构演变

### 单体架构

将业务的所有功能集中在一个项目中开发，达成一个包部署

优点：架构简单、部署成本低

缺点：耦合度高

### 分布式架构

根据业务功能对系统进行划分，每个业务模块作为独立项目开发，称为一个服务

优点：降低服务耦合、有利于服务升级拓展

缺点：复杂（服务拆分、服务治理、远程调用、服务健康状态感知）

### 微服务

一种经过良好架构设计的分布式架构方案，具有以下特征：

- 单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复业务开发
- 面向服务：微服务对外暴露业务接口
- 自治：团队独立、技术独立、数据独立、部署独立
- 隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题

## 1.2 微服务技术对比

在国内比较知名的落地技术为 SpringCloud、Dubbo 和 SpringCloudAlibaba

|                | Dubbo                 | SpringCloud              | SpringCloudAlibaba       |
| -------------- | --------------------- | ------------------------ | ------------------------ |
| 注册中心       | zookeeper、redis      | Eureka、Consul           | Nacos、Eureka            |
| 远程服务调用   | Dubbo  协议           | Feign（http 协议）       | Dubbo、Feign             |
| 配置中心       | 无                    | SpringCloudConfig        | SpringCloudConfig、Nacos |
| 服务网关       | 无                    | SpringCloudGateway、Zuul | SpringCloudGateway、Zuul |
| 服务监控和保护 | Dubbo-admin（功能弱） | Hystrix                  | Sentinel                 |

## 1.3 SpringCloud

SpringCloud是目前国内使用最广泛的微服务框架。官网地址：https://spring.io/projects/spring-cloud。

SpringCloud集成了各种微服务功能组件，并**基于SpringBoot实现了这些组件的自动装配**，从而提供了良好的开箱即用体验：

![image-20231105191905655](微服务.pic/image-20231105191905655.png)

SpringCloud 基于 SpringBoot 提供自动装配服务，因此存在两者的版本兼容问题，准确的兼容关系如下：

![image-20231105192013992](微服务.pic/image-20231105192013992.png)



# 第 2 章 服务拆分及远程调用

任何分布式架构都离不开服务的拆分，微服务也是一样。

## 2.1 服务拆分

### 2.1.1 服务拆分原则

- 单一职责：根据业务模块拆分；不同微服务，不要重复开发相同业务
- 数据独立：独立的数据库，不要访问其它微服务的数据库
- 面向服务：将自己的业务暴露为接口，供其它微服务调用

### 2.1.2 服务拆分示例

以课前资料中的微服务cloud-demo为例，其结构如下：

![image-20210713211009593](微服务.pic/image-20210713211009593.png)

cloud-demo：父工程，管理依赖

- order-service：订单微服务，负责订单相关业务
- user-service：用户微服务，负责用户相关业务

要求：

- 订单微服务和用户微服务都必须有各自的数据库，相互独立
- 订单服务和用户服务都对外暴露Restful的接口
- 订单服务如果需要查询用户信息，只能调用用户服务的Restful接口，不能查询用户数据库

## 2.2 远程调用

### 2.2.1 远程调用方式

- 基于 RestTemplate 发起的 http 请求实现远程调用
- http 请求做远程调用是与语言无关的调用，只要知道对方的 ip、端口、接口路径、请求参数即可。

### 2.2.2 远程调用示例

**需求**

修改 order-service 中的根据 id 查询订单业务，要求在查询订单的同时，根据订单中包含的 userId 查询出用户信息，一起返回。



![image-20210713213312278](微服务.pic/image-20210713213312278.png)



**思路**

我们需要在 order-service 中向 user-service 发起一个 http 的请求，调用 `http://localhost:8081/user/{userId}` 这个接口。

大概的步骤是这样的：

- 注册一个 RestTemplate 的实例到 Spring 容器
- 修改 order-service 服务中的 OrderService 类中的 queryOrderById 方法，根据 Order 对象中的 userId 查询 User
- 将查询的 User 填充到 Order 对象，一起返回

**实现**

1. 注册 RestTemplate

   首先，我们在 order-service 服务中的 OrderApplication 启动类中，注册 RestTemplate 实例：

   ```java
   package com.github.taohe.order;
   
   import org.mybatis.spring.annotation.MapperScan;
   import org.springframework.boot.SpringApplication;
   import org.springframework.boot.autoconfigure.SpringBootApplication;
   import org.springframework.context.annotation.Bean;
   import org.springframework.web.client.RestTemplate;
   
   @MapperScan("com.github.taohe.order.mapper")
   @SpringBootApplication
   public class OrderApplication {
   
       public static void main(String[] args) {
           SpringApplication.run(OrderApplication.class, args);
       }
   
       @Bean
       public RestTemplate restTemplate() {
           return new RestTemplate();
       }
   
   }
   ```

2. 实现远程调用

   修改 order-service 服务中的 com.github.taohe.order.service 包下的 OrderService 类中的 queryOrderById 方法：

   ```java
   package com.github.taohe.order.service;
   
   import com.github.taohe.order.pojo.Order;
   import com.github.taohe.order.mapper.OrderMapper;
   import com.github.taohe.order.pojo.User;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.stereotype.Service;
   import org.springframework.web.client.RestTemplate;
   
   import javax.annotation.Resource;
   
   @Service
   public class OrderService {
   
       @Resource
       private OrderMapper orderMapper;
   
       @Resource
       private RestTemplate restTemplate;
   
       public Order queryOrderById(Long orderId) {
   
           Order order = orderMapper.findById(orderId);
   
           completeOrder(order);
   
           return order;
       }
   
       private void completeOrder(Order order) {
   
           String url = "http://localhost:8081/user/" + order.getUserId();
           User user = restTemplate.getForObject(url, User.class);
           order.setUser(user);
       }
   }
   ```

**结果**

打开 `http://localhost:8080/order/101`，结果如下：

```json
{
	"id": 101,
	"price": 699900,
	"name": "Apple 苹果 iPhone 12 ",
	"num": 1,
	"userId": 1,
	"user": {
		"id": 1,
		"username": "柳岩",
		"address": "湖南省衡阳市"
	}
}
```

### 2.2.3 服务调用关系

- 服务提供者：暴露接口给其它微服务调用
- 服务消费者：调用其它微服务提供的接口
- 提供者与消费者角色其实是**相对**的
- 一个服务可以同时是服务提供者和服务消费者

## 2.3 Eureka 注册中心

### 2.3.1 Eureka 的作用

- 消费者该如何获取服务提供者具体信息？
  - 服务提供者实例启动后，将自己的信息注册到 eureka-server（Eureka服务端）。这个叫服务注册
  - eureka-server 保存服务名称到服务实例地址列表的映射关系
  - 消费者根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取
- 如果有多个服务提供者，消费者该如何选择？
  - 服务消费者从实例列表中利用负载均衡算法选中一个实例地址
  - 向该实例地址发起远程调用
- 消费者如何感知服务提供者健康状态？

  - 服务提供者会每隔一段时间（默认30秒）向 eureka-server 发起请求，报告自己状态，称为心跳
  - 当超过一定时间没有发送心跳时，eureka-server 会认为微服务实例故障，将该实例从服务列表中剔除
  - 消费者拉取服务时，就能将故障实例排除了

> 一个微服务，既可以是服务提供者，又可以是服务消费者，因此 eureka 将服务注册、服务发现等功能统一封装到了 eureka-client 端

![image-20231115214814948](微服务.pic/image-20231115214814948.png)

### 2.3.2 Eureka 架构

在Eureka架构中，微服务角色有两类：

- EurekaServer：服务端，注册中心
  - 记录服务信息
  - 心跳监控

- EurekaClient：客户端
  - Provider：服务提供者，例如案例中的 user-service
    - 注册自己的信息到EurekaServer
    - 每隔30秒向EurekaServer发送心跳
  - consumer：服务消费者，例如案例中的 order-service
    - 根据服务名称从EurekaServer拉取服务列表
    - 基于服务列表做负载均衡，选中一个微服务后发起远程调用

### 2.3.3 搭建 Eureka 服务

首先应该意识到注册中心服务端：eureka-server，这必须是一个独立的微服务

搭建 EurekaServer 服务步骤如下：

1. 创建项目，引入 spring-cloud-starter-netflix-eureka-server 的依赖

   ```xml
   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
   </dependency>
   ```

2. 编写启动类，添加 @EnableEurekaServer 注解

3. 添加 application.yml 文件，编写下面的配置

   ```yaml
   server:
     port: 10086
   spring:
     application:
       name: eurekaserver
   eureka:
     client:
       service-url:
         defaultZone: http://127.0.0.1:10086/eureka/
   ```

   Eureka 本身也是一个微服务，需要有自己的服务名和地址，以方便在多 Eureka 实例时相互沟通
   
4. 启动微服务，然后在浏览器访问：http://127.0.0.1:10086

   看到下面结果应该是成功了：

   ![image-20231115215725719](微服务.pic/image-20231115215725719.png)

### 2.3.4 服务注册

下面，我们将 user-service 注册到 eureka-server 中去。

按照以下两步完成服务注册：

1. 引入 spring-cloud-starter-netflix-eureka-client 的依赖

   ```xml
   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
   </dependency>
   ```

2. 在 application.yml 文件，编写下面的配置

   ```yaml
   spring:
     application:
       name: xxxserver
   eureka:
     client:
       service-url:
         defaultZone: http://127.0.0.1:10086/eureka/
   ```
   
3. 同时启动 eureka-service 和 user-service，在 eureka 控制台可以看到 user-service 上线：

   ![image-20231115220500273](微服务.pic/image-20231115220500273.png)

>  无论是消费者还是提供者，引入 eureka-client 依赖、知道 eureka 地址后，都可以完成服务注册

### 2.3.5 单服务多实例

为了演示一个服务有多个实例的场景，我们添加一个 SpringBoot 的启动配置，再启动一个 user-service。

首先，复制原来的 user-service 启动配置：

![image-20231115220637743](微服务.pic/image-20231115220637743.png)

然后，在弹出的窗口中，填写信息：

> 注意修改端口信息

<img src="微服务.pic/image-20231115221536350.png" alt="image-20231115221536350" style="zoom:80%;" />

> 如果没有 Environment variables 配置项，在此处勾选该项即可：
>
> ![image-20231115221735248](微服务.pic/image-20231115221735248.png)

现在，SpringBoot 窗口会出现两个 user-service 启动配置：

![image-20231115221245026](微服务.pic/image-20231115221245026.png)

不过，第一个是 8081 端口，第二个是 8082 端口。

启动两个 user-service 实例：

![image-20231115221425434](微服务.pic/image-20231115221425434-17000576668911.png)

查看 eureka-server 管理页面：

![image-20231115221502615](微服务.pic/image-20231115221502615.png)

### 2.3.6 服务发现

下面，我们将 order-service 的逻辑修改：向 eureka-server 拉取 user-service 的信息，实现服务发现。

1. 引入依赖

   之前说过，服务发现、服务注册统一都封装在 eureka-client 依赖，因此这一步与服务注册时一致。

   在 order-service 的 pom 文件中，引入下面的 eureka-client 依赖：

   ```xml
   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
   </dependency>
   ```

2. 配置文件

   服务发现也需要知道 eureka 地址，因此第二步与服务注册一致，都是配置 eureka 信息：

   在 order-service 中，修改 application.yml 文件，添加服务名称、eureka 地址：

   ```yml
   spring:
     application:
       name: orderservice
   eureka:
     client:
       service-url:
         defaultZone: http://127.0.0.1:10086/eureka
   ```

3. 服务拉取和负载均衡

   最后，我们要去 eureka-server 中拉取 user-service 服务的实例列表，并且实现负载均衡。

   不过这些动作不用我们去做，只需要添加一些注解即可。

   在 order-service 的 OrderApplication 中，给 RestTemplate 这个 Bean 添加一个 @LoadBalanced 注解：

   ```java
   @Bean
   @LoadBalanced
   public RestTemplate restTemplate() {
       return new RestTemplate();
   }
   ```

   修改 order-service 服务中的 com.github.taohe.order.service.OrderService 类中的 completeOrder 方法。修改访问的 url 路径，用服务名代替 ip、端口：

   ```java
   private void completeOrder(Order order) {
   
       // String url = "http://localhost:8081/user/" + order.getUserId();
       String url = "http://userService/user/" + order.getUserId();
       User user = restTemplate.getForObject(url, User.class);
       order.setUser(user);
   }
   ```

   spring 会自动帮助我们从 eureka-server 端，根据 userservice 这个服务名称，获取实例列表，而后完成负载均衡。

## 2.4 Ribbon 负载均衡

上一节中，我们添加了 @LoadBalanced 注解，即可实现负载均衡功能，这是什么原理呢？

### 2.4.1 负载均衡原理

SpringCloud 底层其实是利用了一个名为 Ribbon 的组件，来实现负载均衡功能的。

![image-20231116082240544](微服务.pic/image-20231116082240544.png)

那么我们发出的请求明明是 `http://userservice/user/1`，怎么变成了 `http://localhost:8081/user/1` 的呢？

## 4.2 源码跟踪

为什么我们只输入了 service 名称就可以访问了呢？之前还要获取 ip 和端口。

显然有人帮我们根据 service 名称，获取到了服务实例的 ip 和端口。它就是`LoadBalancerInterceptor`，这个类会在对 RestTemplate 的请求进行拦截，然后从 Eureka 根据服务 id 获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务 id。

我们进行源码跟踪：

ss